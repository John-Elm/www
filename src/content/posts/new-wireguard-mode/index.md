---
title: "A more user-friendly transparent mode, based on WireGuard"
summary: | 
    The next release of mitmproxy is slated to ship with a new alternative to the existing "transparent" mode, based on
    WireGuard. The new "wireguard" mode was designed to be much simpler to set up and use, and in most cases, it does not
    require taking any actions with elevated privileges.
date: 2022-09-23
weight: 10
tags: [tech]
author:
    name: Fabio Valentini
    twitter: decathorpe
---

The next release of mitmproxy is slated to ship with a new alternative to the existing `transparent` mode, based on
WireGuard. The new `wireguard` mode was designed to be much simpler to set up and use, and in most cases, it does not
require taking any actions with elevated privileges.

Connecting another device and routing its traffic through mitmproxy becomes as simple as connecting to a WireGuard VPN
--- either by using the WireGuard configuration file generated by mitmproxy, or by scanning the QR code that is shown
in the mitmweb interface:

{{<
figure src="mitmweb-wireguard-android.mp4"
caption="Screencast of connecting an Android device to mitmproxy using the official WireGuard app"
width="80%"
>}}

## How it works

The core of this feature is implemented in the [`mitmproxy-wireguard`](https://pypi.org/project/mitmproxy-wireguard/)
Python package, which provides a user-space implementation of a WireGuard server. It is a new dependency of mitmproxy
and will be included by default with the next release.

Because the WireGuard protocol operates by transmitting IP packets, this also involves running a network stack in
userspace to parse incoming IP packets, construct outgoing IP packets, handle TCP connections, and process UDP
datagrams.

{{<
figure src="mitmproxy_wireguard-architecture.png"
caption="Architecture of the WireGuard server implemented in `mitmproxy_wireguard`"
width="80%"
>}}

The interfaces which are provided by `mitmproxy_wireguard` were designed to match the APIs in the Python standard
library's `asyncio` module as closely as possible, in particular, the `TcpStream` provided by the package implements all methods of `asyncio.StreamReader` and `asyncio.StreamWriter` which are expected by mitmproxy, and can be used as a
drop-in replacement.

Oh, and did I mention this already? The `mitmproxy_wireguard` project is written in [Rust](https://rust-lang.org),
utilizing some great Rust libraries to implement this functionality --- most notably:

- [tokio](https://tokio.rs), the de-facto default asynchronous runtime for Rust
- [boringtun](https://github.com/cloudflare/boringtun), a userspace implementation of the WireGuard protocol, developed
  by Cloudflare, deployed on thousands of servers, and running on millions of iOS and Android client devices
- [smoltcp](https://github.com/smoltcp-rs/smoltcp), a standalone, userspace network stack implementation with support
  for all the protocols that are needed to implement `mitmproxy_wireguard`
- [pyo3](https://pyo3.rs), a project that provides Rust bindings for Python and other utility functions for writing code
  that interfaces with both Rust and Python, including support for bridging `async` runtimes of the two languages and
  a compatibility layer for the standard Python `logging` module
- [maturin](https://maturin.rs/), a build tool for Python packages that are implemented in Rust, which supports building
  source distributions and binary wheels that can be published on PyPI

## How to use it

In contrast to the existing `transparent` mode, the `wireguard` mode requires little to no manual configuration. Running
mitmproxy in this mode should be as simple as specifying `--mode wireguard`. By default, mitmproxy will try to load
existing WireGuard encryption keys, but will fall back to generating new keys if they don't exist yet. It will also
listen on the default port for WireGuard servers (51820/udp), which should already be allowed by the local firewall in
most cases.

For example, running `mitmweb` with the new `wireguard` mode and using default settings is as simple as running:

```shell
mitmweb --mode wireguard
```

The mitmweb interface then shows the configuration file and QR code that can be used to connect clients to mitmproxy
via the WireGuard tunnel:

{{<
figure src="mitmweb-wireguard.png"
caption="WireGuard configuration and scannable QR code as shown by mitmweb"
width="80%"
>}}

## What's next?

Support for this WireGuard mode is still very new, and there are likely still bugs, but it should already work for basic
use cases. We're still [collecting feedback](https://github.com/mitmproxy/mitmproxy/issues/5592) (unless you're reading
this in the far future).

There's also a few things that do *not* work yet in this mode --- in particular, the support for IPv6 is still
incomplete, which is why the provided configuration for WireGuard clients will only route IPv4 traffic to mitmproxy.

## Acknowledgements

This project would not have been possible if not for the great ecosystem of existing Rust libraries for asynchronous
programming (tokio), low-level networking functionality (boringtun, smoltcp), and bridging the gap between Rust and
Python (pyo3, pyo3-log, pyo3-asyncio, maturin).

I would also like to thank [Maximilian Hils](https://twitter.com/maximilianhils) for his mentorship and for supervising
my Bachelor thesis --- which, coincidentally, will be about "Implementing a WireGuard frontend for mitmproxy". ðŸ™ƒ
